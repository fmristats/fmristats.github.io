Very quick start
----------------

fmristats provides command line tools which allow to access most of
its functionality, in particular when it comes to fitting the signal
model to individual subject data.

In order to fit a signal model to the FMRI session data of a subject,
you need to first (i) define the *irritation*, *conditioning*, or
*paradigm* of the session, i.e. provide the on- and offsets of the task
blocks as well as their durations, you will need to (ii) separate the
foreground from the background in the 4D FMRI image, and you need to
(iii) estimate (or provide) the location, position and tilt of the
subject's head in the scanner during acquisition. After that, you are
(iv) ready to fit a signal model to your data.

**Do NOT alter your images. Do NOT do motion correction, do NOT correct
for slice timing differences, and do NOT smooth your data.**

Irritation files
................

The following will define a two block task design labelled *FOO* for
subject *42* in the study called *MyStudy* measured on the 1st of
November, 2015 at 12:54, and saves the design in a file ``subject.irr``.
The control block as been labelled *shapes*, the stimulus block has been
labelled *faces*.

.. code:: shell

    fmriirritation --irritation subject.irr \
        --cohort MyStudy \
        --id 42 \
        --datetime 2015-11-01-1254 \
        --paradigm FOO \
        --namex shapes \
        --onsetsx 2 84 166 248 330 \
        --durationsx 30 \
        --namey faces \
        --onsetsy 37 119 201 283 \
        --durationsy 44 \
        --verbose

Use ``-v/--verbose`` to increase verbosity of any fmristats command
line tools.

Session files
.............

Data import is handled by the Nibabel_ project, allowing a flexible
import from various formats for FMRI data. This includes, in particular,
the popular Nifti1 format.

.. _Nibabel: http://nipy.org/nibabel/

Say, FMRI data have been collected and they have been converted from
DICOM to Nifti1 format using the dcm2nii_ tool with (essentially) all
the default settings:

- 4D=1: "will generate 4D files (FSL style)",
- SingleNIIFile=1: "will create .nii files (FSL style)",
- Gzip=1: "will create compressed .nii.gz files (FSL style)",
- SPM2=0: "headers will be in NIfTI (SPM5/FSL)."

.. _dcm2nii: http://people.cas.sc.edu/rorden/mricron/dcm2nii.html

And say, the data have been saved to ``subject.nii.gz``.

Then the FMRI data can be converted to a fmristats session file by
providing ``nii2ses`` with ``subject.nii.gz`` and ``subject.irr``:

.. code:: shell

    nii2ses --session subject.ses \
        --nii subject.nii.gz \
        --irritation subject.irr \
        --epi-code 3 \
        --detect-foreground -v

The above call also runs a foreground detection algorithm. The session
file  will be saved to ``subject.ses``.

The argument ``--epi-code 3`` codes the direction in which the EPI have
been measured during the session. The directions are coded as follows:

======== =====================
EPI code  direction
======== =====================
-3       superior to inferior
-2       anterior to posterior
-1       right to left
 1       left to right
 2       posterior to anterior
 3       inferior to superior
======== =====================

You may also provide more meta data to the call. If you do so,
``nii2ses`` will check if they match the meta data in the provided
irritation file ``subject.irr``.

Alternative call:

.. code:: shell

    nii2ses --session subject.ses \
        --cohort MyStudy \
        --id 42 \
        --datetime 2015-11-01-1254 \
        --paradigm FOO \
        --nii subject.nii.gz \
        --irritation subject.irr \
        --epi-code 3 \
        --detect-foreground -v

By default, *valid* files will not be overwritten: if something does not
match, though, fmristats will delete the file and try to fix things.
Use ``-f/--force`` to force the recreation of any files (valid or not).

You may query information about any file that is created by
fmristats by calling ``fmriinfo`` on the same.

.. code:: shell

    fmriinfo subject.ses

Output:

.. code:: shell

    subject.ses: session file

        Cohort:   MyStudy
        Subject:  42
        Date:     2015-11-01-1254
        Paradigm: FOO

        EPI code: 3

        Type of irritation: block design
        Block number: 2
        Block names:  ['shapes', 'faces']
        Onsets: {'shapes': array(30.0), 'faces': array(44.0)}
        Durations: {'shapes': array([   2.,   84.,  166.,  248.,  330.]),
                    'faces' : array([  37.,  119.,  201.,  283.])}
        Number of onsets per block: {'shapes': 5, 'faces': 4}

        Resolution (left to right):         3.28
        Resolution (posterior to anterior): 3.28
        Resolution (inferior to superior):  4.18
        Diagonal:      6.25
        Volume:        45.00
        Aspect 0 on 1: 1.00
        Aspect 0 on 2: 0.78
        Aspect 1 on 2: 0.78
        Rigid transformation: False

You may also provide more than one file to the call:

.. code:: shell

    fmriinfo subject.irr subject.ses

Reference maps
..............

Fit head movements by, e.g, a PCA model, and save the fitted reference
maps to ``subject.ref``:

.. code:: shell

    fmririgid --ses subject.ses --ref subject.ref -v

Here, you have seen another feature of fmristats: you may shorten
any argument as long it is still uniquely identifiable. The above call is
indeed identical to:

.. code:: shell

    fmririgid -v \
        --session        subject.ses \
        --reference-maps subject.ref

Create some informative plots which evaluate the ability of the PCM
method to track the head of your subject:

.. code:: shell

    ref2plot --ref subject.ref -v

You will see that an outlier detection has been applied to the estimated
head movements. Scan circles which are marked as outlying will not be
used in the fitting.

Fitting the signal model
........................

If you aim for inference, you need to relate all the brains :math:`R_j`
of subjects :math:`j` in your study with one another, i.e. you need to
chose a reference brain :math:`M` and define diffeomorphisms :math:`ψ_j`
which map :math:`M` to each respective :math:`R_j`.

.. math::

    ψ_j: M \to R_j.

But if you are only interested in subject :math:`j`, you may simply set
:math:`M` identical to :math:`R_j` and :math:`ψ_j` equal to the
identity.

The *identity population map* is created as follows:

.. code:: shell

    fmripop --ses subject.ses --population-map subject.pop -v

and saved to ``subject.pop``. The above is equivalent to

.. code:: shell

    fmripop --population-map subject.pop -v
        --session subject.ses \
        --reference-maps subject.ref \
        --population-space reference \
        --resolution 2.0

The space :math:`R_j` is called the *reference space* in fmristats
speech. The option ``--population-space reference`` tells ``fmripop`` to
set :math:`M` equal to :math:`R_j`. As the option ``--resolution 2.0``
suggests, ``fmripop`` will also define and save a grid :math:`V_M ⊆_f M`
to ``subject.pop``.  The grid :math:`V_M` defines where to evaluate and
fit the models in fmristats and with respect to which grid masks shall
be applied if they shall be applied.

Providing ``subject.pop`` to ``fmrifit`` together with the session file
``subject.ses`` and the head movements ``subject.ref`` will fit the
(default) signal model to the data.

.. code:: shell

    fmrifit --fit subject.fit \
        --session subject.ses \
        --reference-maps subject.ref \
        --population-map subject.pop \
        --stimulus-block faces --control-block shapes -v

The above call saves the fit to ``subject.fit``.

Prune non-brain areas from fit
..............................

As RS estimation uses a WLS estimator in its fitting procedure which
uses a weighting scheme with non-null spacial extent, evaluating (i.e.
fitting) a FMRI model close but outside of the actual brain of a subject
will nevertheless result in "valid" parameter estimates. In the case
that ``fmrifit`` is not supplied with a brain mask, these "outside fits"
can be detected post-hoc as they are naturally accompanied by a drastic
drop in available sample size.

By default, ``fmrifit`` will estimate a default *data mask* on :math:`M`
from the foreground/background difference saved in ``subject.ses``. If
this mask still contains non-brain areas, you may want to further prune
the parameter fields from these areas.

The command line programs ``fmriprune`` or ``fsl4prune`` can be used to
generate brain masks. Both commands will force a minimum number of
observations to be available around each grid point in :math:`V_M` by
either setting a user defined hard lower bound for the minimum:

.. code:: shell

    fmriprune --fit subject.fit -vv -t 1800

Or by setting the lower bound to a given fraction of the maximum
available MR measures at a point:

.. code:: shell

    fmriprune --fit subject.fit -vv -p .5 -f

The generated brain mask is directly saved into the file ``subject.fit``.

The difference between ``fmriprune`` and ``fsl4prune`` is that the
latter also contains a wrapper to BET_. The following

.. code:: shell

    fsl4prune --fit subject.fit -p .5 --variant R -v -f

is equivalent to:

.. code:: shell

    fmriprune --fit subject.fit -p .5

    fit2nii --fit subject.fit --nii intercept.nii.gz \
        --parameter intercept --value point \
        --round-to-integer

    bet -R intercept.nii.gz mask.nii.gz

    nii2image mask.nii.gz mask.image

Followed by the python script:

.. code:: python

    from fmristats import *

    result = load('subject.fit')
    mask = load('mask.image')

    result.population_map.set_template_mask(mask)
    result.save('subject.fit')

.. _BET: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/BET

Defining non-trivial population spaces
......................................

If you aim for population inference, you need to relate the brains
:math:`R_j` of all subjects :math:`j` in your study to each another,
i.e. you need to chose a representative, say a template brain :math:`M`
in MNI Standard Space, and fit diffeomorphisms :math:`ψ_j` which map
:math:`M` to each :math:`R_j`.

.. math::

    ψ_j: M \to R_j.

A good candidate for :math:`R_j` is the intercept field of a fit of the
signal model in an isometric coordinate system with respect to the
subject, namely the created ``subject.fit`` above.

This field can then be exported to Nifti1 using ``fit2nii`` and fed to
a tool of your choice.

Extract the intercept from a fit and save the result to
intercept.nii.gz:

.. code:: shell

    fit2nii --fit subject.fit --nii intercept.nii.gz \
        --parameter intercept --value point \
        --round-to-integer

If you are using the software FNIRT_ to fit the respective :math:`ψ_j`,
then you may use the command line tool ``fsl4pop`` (which is distributed
together with fmristats) to parse the `warp coefficient file`_ which is
created by FNIRT_.

.. _FNIRT: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FNIRT

.. _`warp coefficient file`: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FNIRT/UserGuide#A--cout

.. code:: shell

    # you may have done something along the line…

    fsl5.0-fnirt --in=intercept.nii.gz --config=T1_2_MNI152_2mm \
        --cout=intercept_warpcoef.nii.gz

    # provide the argument in: --in   as --nb-nii
    # and:                     --cout as --warpcoef

    fsl4pop --population-map subject-MNI.pop --image MNI.image -v \
        --nb-fit subject.fit \
        --nb-nii intercept.nii.gz \
        --warpcoef intercept_warpcoef.nii.gz

This will save :math:`ψ_j` to ``subject-MNI.pop`` and :math:`M` to
``MNI.image``.

By default (but you may change the defaults), ``fsl4pop`` will assume
that the template ``MNI152_T1_2mm`` has been used to define the domain
of each :math:`ψ_j`, and that FNIRT has been provided with a reference
mask that is a dichotomised version of ``MNI152_T1_2mm_brain``, and both
these files reside in

.. code:: shell

    /usr/share/data/fsl-mni152-templates/MNI152_T1_2mm.nii.gz
    /usr/share/data/fsl-mni152-templates/MNI152_T1_2mm_brain.nii.gz

which is the default location of these files when you installed FSL.

To fit the signal model at all points at which the template mask
``MNI152_T1_2mm_brain`` has valid entries, i.e. grey scale intensities
:math:`>0`, provide ``fmrifit`` with ``subject-MNI.pop`` instead of
``subject.pop``:

.. code:: shell

    fmrifit --fit subject-MNI.fit \
        --session subject.ses \
        --reference-maps subject.ref \
        --population-map subject-MNI.pop \
        --stimulus-block faces --control-block shapes -v

This will save the fit to ``subject-MNI.fit``. Have a look at some of
the meta data:

.. code:: shell

   fmriinfo subject-MNI.pop

   fmriinfo subject-MNI.fit
